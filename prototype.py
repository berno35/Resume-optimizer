# -*- coding: utf-8 -*-
"""prototype.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/berno35/e60a99208fc554fad08b55ab0e13466f/prototype.ipynb

```
# This is formatted as code
```

# Resume Optimizer
"""

#!pip install google-generativeai python-docx pyPDF2 sklearn
!pip install --upgrade google-generativeai
!pip install python-docx
!pip install PyPDF2
!pip install sklearn

import google.generativeai as genai
import os
import re
import PyPDF2
import docx
from sklearn.metrics.pairwise import cosine_similarity
import textwrap
from google.colab import files

"""Setting up the Model"""

# setting up the model
genai.configure(api_key="AIzaSyCr7B-Ox86HFFDqodh2p2pruSTrmgN9MD4")

generation_config ={
    "temperature": 0.5,
    "max_output_tokens": 8192,
    "top_k": 40,
    "top_p": 0.95
}


# adding safety features
safety_settings = [
    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
]

model = genai.GenerativeModel(
    'gemini-2.0-flash-001',
    generation_config=generation_config,
    safety_settings=safety_settings
)

# Function to extract the text from the uploaded resume, include pdf, word or text format

def extract_text_from_pdf(pdf_path):
    text = ""
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        for page in pdf_reader.pages:
            text += page.extract_text()
    return text

def extract_text_from_docx(docx_path):
    doc = docx.Document(docx_path)
    full_text = []
    for para in doc.paragraphs:
        full_text.append(para.text)
    return '\n'.join(full_text)

# To extract different versions of the resume
def extract_text(file_path):
    if file_path.endswith('.pdf'):
        return extract_text_from_pdf(file_path)
    elif file_path.endswith('.docx'):
        return extract_text_from_docx(file_path)
    else:
        with open(file_path, 'r') as file:
            return file.read()

# Using embedding for better similarity match
def get_embedding(text):
    truncated_text = text[:10000]
    result = genai.embed_content(
        model="models/embedding-001",
        content=truncated_text,
        task_type="retrieval_document"
    )
    return result['embedding']

# use cosine to calculate similarity between two texts
def calculate_similarity(text1, text2):
    emb1 = get_embedding(text1)
    emb2 = get_embedding(text2)
    return cosine_similarity([emb1], [emb2])[0][0]



# analyse and refine the resume
# Passing the prompt to Returns structured analysis with: match score, strengths, gaps, and recommendations
def analyze_alignment(resume_text, jd_text):

    prompt = textwrap.dedent(f"""
    **Resume-Job Description Alignment Analysis**

    Analyze how well this resume matches the job description by examining:
    - Required skills/technologies
    - Years and type of experience
    - Education/certifications
    - Keywords and terminology
    - Soft skills and cultural fit

    **Resume Content:**
    {resume_text[:10000]}  # Limiting to first 10k chars for Gemini context

    **Job Description Content:**
    {jd_text[:10000]}

    Provide your analysis in this exact format:

    ### Match Score: [0-100]%
    [Explanation of overall match quality]

    ### Key Strengths:
    - [Strength 1 with specific evidence] from resume
    - [Strength 2 with specific evidence]
    - [Strength 3 with specific evidence]

    ### Critical Gaps:
    - [Missing requirement 1 with impact] (Critical/Important/Nice-to-Have)
    - [Missing requirement 2 with impact]
    - [Missing requirement 3 with impact]

    ### Improvement Recommendations:
    - [Actionable suggestion 1] (most impactful)
    - [Actionable suggestion 2]
    - [Actionable suggestion 3]

    ### Keyword Optimization:
    [List of important JD keywords missing from resume]
    """)

    # Error catch
    try:
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"Analysis failed: {str(e)}"

# Refine the resume to match the job description.
# This Maintains original information while optimizing for the JD

def refine_resume(resume_text, jd_text):

    prompt = textwrap.dedent(f"""
    **Resume Refinement Task**

    You are a professional resume writer. Rewrite this resume to better match the
    target job description while:
    1. Keeping all factual information 100% accurate
    2. Maintaining the original structure and sections
    3. Adding missing keywords from the JD naturally
    4. Reordering content to highlight relevant experience first
    5. Quantifying achievements where possible
    6. Rewrite and include experience to match the JD

    **Original Resume:**
    {resume_text[:10000]}

    **Target Job Description:**
    {jd_text[:10000]}

    **MODIFICATION GUIDELINES:**
    - Incorporate at least 3 key terms from the JD
    - Add a "Relevant Skills" section if missing
    - Ensure work experience highlights JD-relevant accomplishments
    - Optimize the professional summary for this role

    Return ONLY the refined resume text with no additional commentary or analysis.
    Maintain the same format as the original (bullet points, sections, etc).
    """)

# Error catch

    try:
        response = model.generate_content(prompt)

        # Clean up response to ensure only resume content
        refined = response.text
        if refined.startswith("```"):
            refined = refined[3:]
        if refined.endswith("```"):
            refined = refined[:-3]
        return refined.strip()
    except Exception as e:
        return f"Refinement failed: {str(e)}"

"""Generating Cover Letter"""

def generate_cover_letter(resume_text, jd_text):
    # prompt sent to the AI model.It tells the AI towrite a personalized cover letter
    # by pulling relevant info from the candidate's resume and the job description.
    prompt = textwrap.dedent(f"""  # Assigning the prompt here
        **Generate a cover letter based on the job description**

        Resume:
        {resume_text}


        Job Description:
        {jd_text}


        Include:
        - Show how the skills and experience align with the job description
        - Brief summary of relevant experience
        - Express interest in the position and company
        - Include key skills that match the job
        - Passionate closing
        Return only the letter.
    """)

    #get the generated response
    response = model.generate_content(prompt)
    return response.text

# Main function
def main():
    print(" Resume Analyzer & Optimization Tool")
    print("-------------------------------------")

    # File uploads
    print("\n STEP 1: Upload your resume (PDF/DOCX/TXT):")
    uploaded_resume = files.upload()
    resume_file = next(iter(uploaded_resume))
    resume_text = extract_text(resume_file)

    print("\n STEP 2: Upload the job description (PDF/DOCX/TXT):")
    uploaded_jd = files.upload()
    jd_file = next(iter(uploaded_jd))
    jd_text = extract_text(jd_file)

    # Calculate embedding similarity
    print("\n Calculating Semantic")
    similarity_score = calculate_similarity(resume_text, jd_text)
    print(f"\n Semantic Match Score: {similarity_score*100:.1f}%")

    # Detailed analysis
    print("\n Detailed Analysis:")
    analysis = analyze_alignment(resume_text, jd_text)
    print(analysis)

    # Resume refinement
    print("\n Generating optimized resume...")
    optimized_resume = refine_resume(resume_text, jd_text)

    print("\n OPTIMIZED RESUME:")
    print("-------------------")
    print(optimized_resume)

    # Save and offer download
    with open('optimized_resume.txt', 'w') as f:
        f.write(optimized_resume)
    print("\n Download your optimized resume:")
    files.download('optimized_resume.txt')

    # Generate Cover Letter
    print("\n Generating cover letter...")
    cover_letter = generate_cover_letter(resume_text, jd_text)
    print("\n COVER LETTER:")
    print("-------------------")
    print(cover_letter)

    # Save the generated cover letter to a text file for download
    with open('cover_letter.txt', 'w') as f:
        f.write(cover_letter)

    # Provide a link for the user to download the saved cover letter
    print("\n Download your personalized cover letter:")
    files.download('cover_letter.txt')

if __name__ == "__main__":
    main()